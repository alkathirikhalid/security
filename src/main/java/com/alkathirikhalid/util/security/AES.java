/*
 * Copyright 2015 Al-Kathiri Khalid www.alkathirikhalid.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.alkathirikhalid.util.security;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * <p>Advanced Encryption Standard utility.</p>
 * <p>Provides a way to Encrypt and Decrypt texts.</p>
 * <p><strong>It is important to note this utility class is only applicable for UTF
 * input types and more secure ways might be required for different applications</strong>.</p>
 *
 * @author alkathirikhalid
 * @version 1.01
 */
public class AES {

    /**
     * <p><code>AES</code> instances should <strong>NOT</strong> be created. The
     * class should be used as:
     * <code>AES.encrypt(plainText, encryptionKey, IV);</code>. The IV can
     * either be passed into the method or be generated by
     * <code>SaltAndHash.getSalt().substring(0, 16);</code>.</p>
     */
    private AES() {
    }

    /**
     * <p>Encrypts input texts.</p>
     *
     * @param plainText the text to be encrypted.
     * @param encryptionKey the private or secret key.
     * @param IV the initialization vector, a random text that prevents the same
     * plaintext from always being transformed into the same ciphertext this is
     * 16 bytes or 128 bits.
     * @return the encrypted ciphertext.
     * @throws NoSuchAlgorithmException thrown when a particular cryptographic
     * algorithm is requested but is not available in the environment.
     * @throws NoSuchProviderException thrown when a particular security
     * provider is requested but is not available in the environment.
     * @throws NoSuchPaddingException thrown when a particular padding mechanism
     * is requested but is not available in the environment.
     * @throws UnsupportedEncodingException thrown when the Character Encoding
     * is not supported.
     * @throws InvalidKeyException thrown when invalid encoding, wrong length,
     * uninitialized.
     * @throws InvalidAlgorithmParameterException thrown for invalid or
     * inappropriate algorithm parameters.
     * @throws IllegalBlockSizeException thrown when the length of data provided
     * to a block cipher is incorrect.
     * @throws BadPaddingException thrown when a particular padding mechanism is
     * expected for the input data but the data is not padded properly.
     */
    public static byte[] encrypt(String plainText, String encryptionKey, String IV) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        plainText = checkAndPatch(plainText);
        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding", "SunJCE");
        SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes("UTF-8"), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV.getBytes("UTF-8")));
        return cipher.doFinal(plainText.getBytes("UTF-8"));
    }

    /**
     * <p>Decrypts Ciphertext.</p>
     *
     * @param cipherText the encrypted ciphertext to be decrypted.
     * @param encryptionKey the private or secret key used to encrypt the text.
     * @param IV the initialization vector used during encryption.
     * @return the decrypted text.
     * @throws NoSuchAlgorithmException thrown when a particular cryptographic
     * algorithm is requested but is not available in the environment.
     * @throws NoSuchProviderException thrown when a particular security
     * provider is requested but is not available in the environment.
     * @throws NoSuchPaddingException thrown when a particular padding mechanism
     * is requested but is not available in the environment.
     * @throws UnsupportedEncodingException thrown when the Character Encoding
     * is not supported.
     * @throws InvalidKeyException thrown when invalid encoding, wrong length,
     * uninitialized.
     * @throws InvalidAlgorithmParameterException thrown for invalid or
     * inappropriate algorithm parameters.
     * @throws IllegalBlockSizeException thrown when the length of data provided
     * to a block cipher is incorrect.
     * @throws BadPaddingException thrown when a particular padding mechanism is
     * expected for the input data but the data is not padded properly.
     */
    public static String decrypt(byte[] cipherText, String encryptionKey, String IV) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding", "SunJCE");
        SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes("UTF-8"), "AES");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV.getBytes("UTF-8")));
        return new String(cipher.doFinal(cipherText), "UTF-8");
    }

    /**
     * <p>A utility inner method that allows an input text of a value other than 16
     * bytes or 128 bits to be encrypted.</p>
     *
     * @param plainText the text to be encrypted.
     * @return the formated input text to be encrypted.
     */
    private static String checkAndPatch(String plainText) {
        int size = plainText.length();
        if (size % 16 == 0) {
            return plainText;
        } else {
            int remainder = size % 16;
            int patch = 16 - remainder;
            while (patch != 0) {
                plainText += "\0";
                patch--;
            }
            return plainText;
        }
    }
}
